#ifndef RTFF_FILTER_H_
#define RTFF_FILTER_H_

#include <complex>
#include <memory>
#include <system_error>
#include <vector>

#include "rtff/buffer/audio_buffer.h"
#include "rtff/buffer/ring_buffer.h"

namespace rtff {

class FilterImpl;

/**
 * @brief Base class of frequential filters.
 * Feed Time/Amplitude audio data and process them and Time/Frequency
 * @example
 *   class MyFilter: public Filter {
 *    private:
 *     void ProcessFreqBlock(FrequentialBuffer* buffer) override {
 *       IMPLEMENT YOUR FILTER
 *     }
 *   };
 *   auto f = MyFilter();
 *   f.Init(512, 2, err);
 *   f.ProcessBlock(my_audio_data);
 */
class Filter {
 public:
  Filter();
  /**
   * @brief Initialize the filter
   * @param block_size: the length in frame of input buffers (fed to
   * ProcessBlock)
   * @param channel_count: the number of channel of input buffers
   * @param err
   */
  void Init(uint32_t block_size, uint8_t channel_count, std::error_code& err);

  /**
   * @brief Converts the input AudioBuffer to a Frequential buffer and calls
   * ProcessFreqBlock
   * @param buffer
   */
  void ProcessBlock(AudioBuffer* buffer);

  /**
   * @brief The latency generated by the filter in frames.
   */
  virtual uint32_t FrameLatency() const;

  uint32_t fft_size() const;
  uint32_t overlap() const;
  uint32_t hop_size() const;
  uint32_t window_size() const;

 protected:
  /**
   * @brief Process a frequential buffer.
   * @note that function is called by the ProcessBlock function. It shouldn't be
   * called on its own
   */
  virtual void ProcessTransformedBlock(std::vector<std::complex<float>*> data,
                                       uint32_t size) = 0;

 private:
  uint32_t fft_size_;
  uint32_t overlap_;
  RingBuffer input_buffer_, output_buffer_;

  std::shared_ptr<FilterImpl> impl_;

  class Impl;
  std::shared_ptr<Impl> buffers_;
};

}  // namespace rtff

#endif  // RTFF_FILTER_H_
